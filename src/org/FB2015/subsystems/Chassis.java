// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.FB2015.subsystems;

import org.FB2015.Robot;
import org.FB2015.RobotMap;
import org.FB2015.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.can.*;
import edu.wpi.first.wpilibj.TalonSRX;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class Chassis extends Subsystem {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	CANTalon frontLeft = RobotMap.chassisFrontLeft;
	CANTalon frontRight = RobotMap.chassisFrontRight;
	CANTalon rearLeft = RobotMap.chassisRearLeft;
	CANTalon rearRight = RobotMap.chassisRearRight;
	RobotDrive robotDrive = RobotMap.chassisRobotDrive;
	
	static final int MS_NORMAL = 0;
	static final int MS_KIM = 1;

	int mechanumStyle = MS_NORMAL;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		setDefaultCommand(new CmdDrive());
	}

	public void mechanumDrive(double x, double y, double z) {
		switch(mechanumStyle) {
			case MS_NORMAL:
				robotDrive.mecanumDrive_Cartesian(x, y, z, 0);
				break;
			case MS_KIM:
				customMechanum(x, y, z);
				break;
		}
	}

	public void switchDrive() {
		switch(mechanumStyle) {
			case MS_NORMAL:
				mechanumStyle = MS_KIM;
				break;
			case MS_KIM:
				mechanumStyle = MS_NORMAL;
				break;
		}
	}

	private void customMechanum(double x, double y, double z) {
		y = -y;
		// start of kim's custom mechanum code
		/*
		 * double total = Math.abs(y) + Math.abs(x) + Math.abs(z);
		 * 
		 * double perY = Math.abs(y) / total; double perX = Math.abs(x) / total;
		 * double perZ = Math.abs(z) / total;
		 * 
		 * System.out.println("front left: y: " + Math.abs(y) + " x: " +
		 * Math.abs(x) + " z: " + Math.abs(z));
		 * 
		 * frontLeft.set((perY * -y) + (perX * x) + (perZ * z));
		 * 
		 * rearLeft.set((perY * -y) + (perX * -x) + (perZ * z));
		 * 
		 * frontRight.set((perY * -y) + (perX * x) + (perZ * -z));
		 * 
		 * rearRight.set((perY * -y) + (perX * -x) + (perZ * -z));
		 */

		// System.out.println("X: " + x + " Y: " + y + " Z: " + z);

		// double total = x - y + z;

		/*
		 * if (total > 1) { x = x / total; y = y / total; z = z / total; }
		 */
		// System.out.println(total);
		// System.out.println("devide total = X: " + x + " Y: " + y + " Z: " +
		// z);
		double multiplier = Math.abs(x) + Math.abs(y) + Math.abs(z);
		if (multiplier < 1) {
			multiplier = 1;
		}
		double fl = (x + y + z) / multiplier;
		double rl = (-x + y + z) / multiplier;
		double fr = (x + y + -z) / multiplier;
		double rr = (-x + y + -z) / multiplier;

		// normalize
		/*
		 * double largest = 0; largest = larger(largest, fl); largest =
		 * larger(largest, rl); largest = larger(largest, fr); largest =
		 * larger(largest, rr); if (largest > 1) { fl = fl / largest; rl = rl /
		 * largest; fr = fr / largest; rr = rr / largest; }
		 * System.out.println("fl: " + fl + "rl: " + rl + "fr: " + fr + "rr: " +
		 * rr);
		 */

		frontLeft.set(fl);
		rearLeft.set(rl);
		frontRight.set(fr);
		rearRight.set(rr);

	}

	private double larger(double a, double b) {
		if (Math.abs(a) > Math.abs(b)) {
			return Math.abs(a);
		} else
			return Math.abs(b);
	}
}
